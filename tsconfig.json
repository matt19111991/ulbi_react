{
  "compilerOptions": {
    "baseUrl": ".", // для абсолютных импортов

    "paths": {
      "*": ["./src/*"] // для абсолютных импортов. Должна быть консистентность с Webpack (resolve => modules)
    },

    "outDir": "./dist/", // куда производится сборка. Значение неважно, т.к. за это отвечает Webpack
    "noImplicitAny": true, // тип 'any' можно указывать только явно
    "module": "ESNext", // система модулей. Чаще всего 'ESNext' или 'es6'

//   конечная версия стандарта EcmaScript, в которую будет компилироваться код (для улучшения поддержки браузеров)
    "target": "es5",

/*  строгий режим (лучше всегда включать)
    Например, при попытке доступа к полю у пустого массива 'data' => data.username
    не будет выброшена ошибка, если 'strict: false';

*/  "strict": true,

    "jsx": "react-jsx", // можно избавиться от "import React from 'react';" в каждом файле с JSX
    "allowJs": true, // компилятор будет обрабатывать не только TS, но и JS файлы
    "moduleResolution": "node", // определяет: какие будут импорты. 99% случаев => 'node'

/*  esModuleInterop позволяет работать с пакетами, которые используют CommonJS, как с ES6 модулями:
    const path = require('path') | module.exports => import path from 'path';
*/  "esModuleInterop": true,

/*
    Если какая-то библиотека не имеет default import, то ts-loader или babel-loader создадут их:
    import * as path from 'path'; => import path from 'path';
*/  "allowSyntheticDefaultImports": true
  },

/* если поле 'includes' не указано: tsconfig работает для всех .ts(x) файлов
   если указано: нужно перечислить все папки, которые должны проверяться TypeScript-ом
*/"include": [
    "./config/jest/setupTests.ts",
    "./src/**/*.ts",
    "./src/**/*.tsx"
  ],

  "ts-node": {
    "compilerOptions": {
      "module": "CommonJS" // исправляет SyntaxError: Cannot use import statement outside a module для webpack.config
    }
  }
}
